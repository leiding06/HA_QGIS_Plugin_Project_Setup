# -*- coding: utf-8 -*-
"""
/***************************************************************************
 HAProjectSetup
                                 A QGIS plugin
 This plugin is for project setup and setup QC.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-02-06
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Lei Ding
        email                : lei.ding@headlandarchaeology.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QButtonGroup
from qgis.core import QgsCoordinateReferenceSystem, QgsProject, QgsMapLayer, QgsCoordinateTransform, QgsFeatureRequest, QgsFeature, QgsMapLayerProxyModel, QgsVectorLayer, QgsProcessingFeatureSourceDefinition
from qgis.utils import iface
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QDialog, QVBoxLayout, QLabel, QDialogButtonBox, QApplication, QFileDialog
from qgis import processing
from qgis.gui import QgsMapLayerComboBox
from PyQt5.QtCore import QVariant

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ha_project_setup_dialog import HAProjectSetupDialog
import os.path


class HAProjectSetup:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'HAProjectSetup_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&HA-Project Setup')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('HAProjectSetup', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            pass

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ha_project_setup/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'<b>HA-Project-Setup</b>'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&HA-Project Setup'),
                action)
            self.iface.removeToolBarIcon(action)
        #Function for 
        # Layer combo box only visible when checkbox is checked - line 219
    def toggle_prow_combobox(self, checked):
        """ Show prowComboBox only when prowLayerBox is checked """
        self.dlg.prowComboBox.setVisible(checked)
    def toggle_map_combobox(self, checked):
        """ Show prowComboBox only when prowLayerBox is checked """
        self.dlg.mapComboBox.setVisible(checked)
    def toggle_constraint_combobox(self, checked):
        """ Show prowComboBox only when prowLayerBox is checked """
        self.dlg.proposedLayer.setVisible(checked)
        self.dlg.label_proposed.setVisible(checked)
    
    def toggle_trStakout_comboxbox(self, checked):
        self.dlg.trStakeoutComboBox.setVisible(checked)

    # Make checkbox exclusive but stick can be cancelled.
    def toggle_checkboxes(self, checkbox, other_checkbox):
        """
        Toggles the clicked checkbox. If it was checked, uncheck it.
        Ensures only one checkbox is active at a time.
        """
        if checkbox.isChecked():
            other_checkbox.setChecked(False)  # Uncheck the other checkbox
        else:
            checkbox.setChecked(False)  # Allow unchecking

    #function for check utility line set within buffer zone
    def check_utility_line(self, lineLayer,bufferLayer, type):
        processing.run("native:selectbylocation", {
                            'INPUT':lineLayer.source(),
                            'PREDICATE':[6],
                            'INTERSECT': bufferLayer.source(),
                            'METHOD':0})
        lineLayer.invertSelection()                
        selected_feature_count = lineLayer.selectedFeatureCount()

        if selected_feature_count == 0:
            QMessageBox.information(None, "Utility Lines Checker", 
                                    f"Wheeeeee! All {type} lines are safely stayed in buffers")
        else:
            QMessageBox.warning(None, "Utility Lines Checker", 
                                f'{selected_feature_count} {type} utility lines are not within the buffer zone. \nThey have been selected in attribute table.')  
    
    #function for trench stakeout
    def trench_stakeout_func(self):
        proposed_layer = self.dlg.trStakeoutComboBox.currentLayer()
        if proposed_layer is None:
        
            iface.messageBar().pushWarning("Proposed Stakeout", 'Please select a valid proposed archaeology layer')
            raise Exception("No valid proposed archaeology layer found.")  # 直接抛出异常，停止执行

        if proposed_layer.readOnly() is True:
            proposed_layer.setReadOnly(False)


        select = processing.run("qgis:selectbyexpression", {
            'INPUT': proposed_layer,
            'EXPRESSION': '"Type" = \'t\'',
            'METHOD':0
        })

        tr_count = proposed_layer.selectedFeatures()

        if not tr_count:
            iface.messageBar().pushWarning('Proposed Trench Stakeout', 'There is no trench in your selected layer')
            raise Exception("No trench in your layer.")
        polygonToLine = processing.run("native:polygonstolines", {
            'INPUT': QgsProcessingFeatureSourceDefinition(proposed_layer.source(),selectedFeaturesOnly = True,
            featureLimit = -1,
            geometryCheck=QgsFeatureRequest.GeometryAbortOnInvalid),
            'OUTPUT':'TEMPORARY_OUTPUT'
            })

        proposed_line = polygonToLine ['OUTPUT']
        #proposed_line.setName("proposedLine")
        #QgsProject.instance().addMapLayer(proposed_line)


        explodeLine = processing.run("native:explodelines",{
            'INPUT': proposed_line,
            'OUTPUT':'TEMPORARY_OUTPUT'
        })

        explode_line = explodeLine['OUTPUT']
        #explode_line.setName("explodeLine")
        #QgsProject.instance().addMapLayer(explode_line)

        addGeometry = processing.run("qgis:exportaddgeometrycolumns", {
            'INPUT': explode_line,
            'CALC_METHOD':0,
            'OUTPUT':'TEMPORARY_OUTPUT'
        })

        add_geometry = addGeometry['OUTPUT']
        #add_geometry.setName('addGeometry')
        #QgsProject.instance().addMapLayer(add_geometry)

        selectByAttribute = processing.run("qgis:selectbyattribute",{
            'INPUT': add_geometry,
            'FIELD':'length',
            'OPERATOR':5,
            'VALUE':'3',
            'METHOD':0
        })

        select_by_attribute = selectByAttribute['OUTPUT']
        #select_by_attribute.setName('selectByAttribute')
        #QgsProject.instance().addMapLayer(select_by_attribute)


        extractSelectedFeature = processing.run("native:saveselectedfeatures", {
            'INPUT': select_by_attribute,
            'OUTPUT': 'TEMPORARY_OUTPUT'
        })


        extract_selected = extractSelectedFeature['OUTPUT']

        centroid = processing.run("native:centroids", {
            'INPUT': extract_selected,
            'ALL_PARTS': False,
            'OUTPUT': 'TEMPORARY_OUTPUT'
        })

        centroid_point = centroid['OUTPUT']
        centroid_point.setName('Trench_Stakeout_Point')
        QgsProject.instance().addMapLayer(centroid_point)
        proposed_layer.removeSelection() 
        iface.mapCanvas().refresh()

    #function for other stakeout
    def other_stakeout_func(self):
        for layer in iface.layerTreeView().selectedLayers():
            if "Proposed Archaeology" in layer.name():
                layer.removeSelection() 
                iface.mapCanvas().refresh()
                selected= processing.run("qgis:selectbyattribute",{
                'INPUT': layer,
                'FIELD':'Type',
                'OPERATOR':1,
                'VALUE':'t',
                'METHOD':0
                })
                selected = selected['OUTPUT']

                iface.mapCanvas().refresh()
                result = processing.run("native:extractvertices", {
                'INPUT': QgsProcessingFeatureSourceDefinition(layer.source(),selectedFeaturesOnly=True, featureLimit=-1 ),
                'OUTPUT': 'TEMPORARY_OUTPUT'   
                })

            
            else:
                result = processing.run("native:extractvertices", {
                    'INPUT': layer,
                    'OUTPUT': 'TEMPORARY_OUTPUT'   
                })

            vertex_layer = result['OUTPUT']
            vertex_layer.setName(f"temp_vertex_{layer.name()}")
            QgsProject.instance().addMapLayer(vertex_layer)
            layer.removeSelection() 

        temp_layers = [layer for layer in QgsProject.instance().mapLayers().values() if layer.name().startswith('temp_vertex_')]
        if temp_layers:
            merge_result = processing.run(
                "native:mergevectorlayers",
                {
                    'LAYERS': temp_layers,
                    'CRS': 'EPSG:27700',
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                }
            )
            merged_layer = merge_result['OUTPUT']
            merged_layer.setName(f"merged_vertex_for_stakeout")
            QgsProject.instance().addMapLayer(merged_layer)

        for layer in temp_layers:
            QgsProject.instance().removeMapLayer(layer)
            
   

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = HAProjectSetupDialog()
        #Manually exclusive each other
        self.dlg.prowCanvasBox.clicked.connect(lambda: self.toggle_checkboxes(self.dlg.prowCanvasBox, self.dlg.prowLayerBox))
        self.dlg.prowLayerBox.clicked.connect(lambda: self.toggle_checkboxes(self.dlg.prowLayerBox, self.dlg.prowCanvasBox))
        self.dlg.mapCanvasBox.clicked.connect(lambda: self.toggle_checkboxes(self.dlg.mapCanvasBox, self.dlg.mapLayerBox))
        self.dlg.mapLayerBox.clicked.connect(lambda: self.toggle_checkboxes(self.dlg.mapLayerBox, self.dlg.mapCanvasBox))
        self.dlg.trStakeoutBox.clicked.connect(lambda: self.toggle_checkboxes(self.dlg.trStakeoutBox, self.dlg.constraintBox))

        # Ensure checkboxes start unchecked
        self.dlg.utilityBox.setChecked(False)
        self.dlg.aDrive.setChecked(False)
        self.dlg.prowCanvasBox.setChecked(False)
        self.dlg.prowLayerBox.setChecked(False)
        self.dlg.mapCanvasBox.setChecked(False)
        self.dlg.mapLayerBox.setChecked(False)
        self.dlg.constraintBox.setChecked(False)
        self.dlg.trMachineBox.setChecked(False)
        self.dlg.trStakeoutBox.setChecked(False)
        self.dlg.otherStakeoutBox.setChecked(False)
        self.dlg.utilityLineBox.setChecked(False)
        self.dlg.directoryBox.setChecked(False)


        # Layer combo box only visible when checkbox is checked
        self.dlg.prowComboBox.setVisible(self.dlg.prowLayerBox.isChecked())
        self.dlg.mapComboBox.setVisible(self.dlg.mapLayerBox.isChecked())
        self.dlg.proposedLayer.setVisible(self.dlg.constraintBox.isChecked())
        self.dlg.proposedLayer.setVisible(self.dlg.trMachineBox.isChecked())
        self.dlg.label_proposed.setVisible(self.dlg.constraintBox.isChecked())
        self.dlg.label_proposed.setVisible(self.dlg.trMachineBox.isChecked())
        self.dlg.trStakeoutComboBox.setVisible(self.dlg.trStakeoutBox.isChecked())

        self.dlg.prowLayerBox.toggled.connect(self.toggle_prow_combobox)
        self.dlg.mapLayerBox.toggled.connect(self.toggle_map_combobox)
        self.dlg.constraintBox.toggled.connect(self.toggle_constraint_combobox)
        self.dlg.trMachineBox.toggled.connect(self.toggle_constraint_combobox)
        self.dlg.trStakeoutBox.toggled.connect(self.toggle_trStakout_comboxbox)


        # Set polygon only
        self.dlg.prowComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dlg.mapComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dlg.proposedLayer.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dlg.trStakeoutComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)

        # Ensure comboboxes are hidden at startup
      
        # show the dialog
        self.dlg.show()

     
 
        # Run the dialog event loop
        result = self.dlg.exec_()
       
        #Filter not working for some reason, ignore
        #self.dlg.mapComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        #self.dlg.prowComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        
        # See if OK was pressed
        if result:
            # 0. Checkbox linked functions
            
            utility_buffer = self.dlg.utilityBox.isChecked()
            prow_canvas = self.dlg.prowCanvasBox.isChecked()
            prow_layer = self.dlg.prowLayerBox.isChecked()
            map_canvas = self.dlg.mapCanvasBox.isChecked()
            map_layer = self.dlg.mapLayerBox.isChecked()
            constraint_checker = self.dlg.constraintBox.isChecked()
            aDrive_checker = self.dlg.aDrive.isChecked()
            check_directory = self.dlg.directoryBox.isChecked()
            check_utilityLine = self.dlg.utilityLineBox.isChecked()
            tr_machineSpace = self.dlg.trMachineBox.isChecked()
            tr_stakeout = self.dlg.trStakeoutBox.isChecked()
            other_stakeout = self.dlg.otherStakeoutBox.isChecked()


            if aDrive_checker:
                datto = 'A'
            else:
                datto = 'M'
            # 1. utility buffer
            if utility_buffer:   
                ug_name = 'Services UG'
                oh_name = 'Services OH'


                ug_layer = QgsProject.instance().mapLayersByName(ug_name)[0] if QgsProject.instance().mapLayersByName(ug_name) else None
                oh_layer = QgsProject.instance().mapLayersByName(oh_name)[0] if QgsProject.instance().mapLayersByName(oh_name) else None

                if not ug_layer:
                    iface.messageBar().pushWarning('Utility Buffer:', 'UG Buffer layer not found')
                    exit()
                if not oh_layer:
                    iface.messageBar().pushWarning('Utility Buffer:', 'OH Buffer layer not found')
                    exit()
              

                def create_buffer(layer, layer_type):
                    special_index = layer.fields().indexFromName('Special') if layer.fields().indexFromName('Special') >= 0 else None
                    type_index = layer.fields().indexFromName('Type')
                    
                    for feat in layer.getFeatures():
                        type_value = feat[type_index]
                        buffer_distance = 0  # Default buffer distance
                        layer.selectByIds([feat.id()])
                        if special_index is not None:
                            special_value = feat[special_index]
                            if special_value > 0:
                                buffer_distance = float(special_value)
                            elif layer_type == 'UG' and type_value == 'gh':
                                buffer_distance = 10
                            elif layer_type == 'UG':
                                buffer_distance = 5
                            elif layer_type == 'OH' and type_value == '275+':
                                buffer_distance = 20
                                
                            elif layer_type == 'OH' and type_value in ['132', '66', 'u']:#new update below 20241223
                                buffer_distance = 15
                            else:
                                buffer_distance = 10
                        else:
                            # If 'Special' does not exist, use defaults based on 'Type'
                            if layer_type == 'UG' and type_value == 'gh':
                                buffer_distance = 10
                            elif layer_type == 'UG':
                                buffer_distance = 5
                            elif layer_type == 'OH' and type_value == '275+':
                                buffer_distance = 20
                            elif layer_type == 'OH' and type_value in ['132', '66', 'u']:#new update below 20241223
                                buffer_distance = 15
                            else:
                                buffer_distance = 10

                        # Create buffer for selected feature geometry
                        buffer_result = processing.run(
                            "native:buffer",
                            {
                                'INPUT': QgsProcessingFeatureSourceDefinition(layer.source(),selectedFeaturesOnly=True),  
                                'DISTANCE': buffer_distance,
                                'SEGMENTS': 5,
                                'END_CAP_STYLE': 0,
                                'JOIN_STYLE': 0,
                                'MITER_LIMIT': 2,
                                'DISSOLVE': False,
                                'SEPARATE_DISJOINT': False,
                                'OUTPUT': 'TEMPORARY_OUTPUT'
                            }
                        )

                        # Add each buffer result to the project
                        buffer_layer = buffer_result['OUTPUT']
                        buffer_layer.setName(f"temp_{layer_type.lower()}_{feat.id()}")
                        QgsProject.instance().addMapLayer(buffer_layer)

                # Create buffers for both UG and OH layers
                create_buffer(ug_layer, 'UG')
                create_buffer(oh_layer, 'OH')

                # Function to merge and dissolve temporary layers
                def merge_and_dissolve(layer_prefix, output_layer_name):
                    temp_layers = [layer for layer in QgsProject.instance().mapLayers().values() if layer.name().startswith(layer_prefix)]
                    
                    # Merge temporary layers
                    merge_result = processing.run(
                        "native:mergevectorlayers",
                        {
                            'LAYERS': temp_layers,
                            'CRS': 'EPSG:27700',
                            'OUTPUT': 'TEMPORARY_OUTPUT'
                        }
                    )
                    merged_layer = merge_result['OUTPUT']
                    
                    # Dissolve merged layer
                    dissolve_result = processing.run(
                        "native:dissolve",
                        {
                            'INPUT': merged_layer,
                            'OUTPUT': 'TEMPORARY_OUTPUT'
                        }
                    )
                    dissolved_layer = dissolve_result['OUTPUT']
                    dissolved_layer.setName(output_layer_name)
                    
                    # Add dissolved layer to project and remove temp layers
                    QgsProject.instance().addMapLayer(dissolved_layer)
                    for layer in temp_layers:
                        QgsProject.instance().removeMapLayer(layer)

                # Merge and dissolve temporary UG and OH layers
                merge_and_dissolve('temp_ug', 'Buffer_TEMP_Underground')
                merge_and_dissolve('temp_oh', 'Buffer_TEMP_Overhead')

                layer_pairs = [("Buffer_TEMP_Underground", "Buffer Underground"),("Buffer_TEMP_Overhead","Buffer Overhead")]
                for src_name, tgt_name in layer_pairs:
                    QgsProject.instance().reloadAllLayers()
                    src_layer = QgsProject.instance().mapLayersByName(src_name)
                    if len(src_layer) == 0:
                        print('No new {}.'.format(src_name))
                        continue
                    src_layer = src_layer[0]
                    tgt_layer = QgsProject.instance().mapLayersByName(tgt_name)


                    if len(tgt_layer) == 0:
                        print('Layer {} does not exist. Please make sure your master layers are having the correct template name!'.format(tgt_name))
                        continue
                    tgt_layer = tgt_layer[0]
                    if tgt_layer.readOnly() is True:
                        tgt_layer.setReadOnly(False)
                    fid=tgt_layer.fields().field("fid")
                    fid=0
                    tgt_layer.startEditing()
                    tgt_layer.deleteFeatures(tgt_layer.allFeatureIds())
                    src_layer.selectAll()
                    iface.mapCanvas().refresh()
                    features = [feature for feature in src_layer.getFeatures()]
                    for feature in features:
                        fid += 1
                    iface.copySelectionToClipboard(src_layer)
                    iface.pasteFromClipboard(tgt_layer)
                    tgt_layer.commitChanges()
                    print('Yes! {} features were added to {}.'.format(len(features), tgt_layer.name()))
                    QgsProject.instance().removeMapLayer(src_layer)
                    iface.messageBar().pushSuccess('Utility Buffer:',' Generated!')
           
            if prow_canvas:
                code = []
                grid_gpkg_path = datto + ":/Data/OS OpenData/BNG/OS_bng_grids.gpkg|layername=100km_grid"
                gpkg_base_path = datto +":/Data/OS OpenData/PRoW_non_definitive"
                layer_name = 'Public Path'
                grid_gpkg_file = grid_gpkg_path.split('|')[0]  # Extract the actual file path before |layername
                gpkg_base_dir = gpkg_base_path.split('|')[0]  # Extract the base path before |layername
    
                if not os.path.isfile(grid_gpkg_file) or not os.path.isdir(gpkg_base_dir):
                    iface.messageBar().pushWarning("PRoW by Canvas", "Wrong Drive or Invalid File Path")
                    return
                if os.path.isfile(grid_gpkg_path.split('|')[0]):  
                    grid_layer = QgsProject.instance().addMapLayer(QgsVectorLayer(grid_gpkg_path, "Grid Layer", "ogr"))
                    
                    canvas_extent = iface.mapCanvas().extent()

                    project_crs = QgsProject.instance().crs()
                    canvas_crs = iface.mapCanvas().mapSettings().destinationCrs()
                    if project_crs != canvas_crs:
                        canvas_extent = QgsCoordinateTransform(canvas_crs, project_crs, QgsProject.instance()).transform(canvas_extent)


                    request = QgsFeatureRequest().setFilterRect(canvas_extent)
                    intersecting_grids = []

                    for grid_feature in grid_layer.getFeatures(request):

                        tile_name = grid_feature['tile_name']
                        intersecting_grids.append(tile_name)

                        code.append(tile_name)

                
                    if intersecting_grids:
                        print(f"Intersecting grid(s) found with tile names: {', '.join(intersecting_grids)}")
                    else:
                        print("No intersecting grids found.")
                    

                    for current_code in code:
                        gpkg_path = f"{gpkg_base_path}/{current_code}_PRoW.gpkg|layername={current_code}_PRoW"
                        
                        if os.path.isfile(gpkg_path.split('|')[0]):  # Check if the PRoW GeoPackage file exists

                            result = processing.run("native:extractbyextent", {
                                'INPUT': gpkg_path,
                                'EXTENT': canvas_extent,
                                'CLIP': True,
                                'OUTPUT': 'TEMPORARY_OUTPUT'
                            })

                            clipped_layer = result['OUTPUT']
                            clipped_layer.setName(f"temp_{layer_name}")
                            QgsProject.instance().addMapLayer(clipped_layer)

                            
                            tgt_layer = QgsProject.instance().mapLayersByName(layer_name)[0] if QgsProject.instance().mapLayersByName(layer_name) else None

                            if not tgt_layer:
                                iface.messageBar().pushWarning('Public Path:', '"Public Path" layer not found, please check layer name')
                                return 1
                            if tgt_layer.readOnly() is True:
                                tgt_layer.setReadOnly(False)

                            tgt_layer.startEditing()  # Enable editing
                            for feature in clipped_layer.getFeatures():
                                new_feature = QgsFeature(tgt_layer.fields())
                                new_feature.setGeometry(feature.geometry())
                                
                                for field in feature.fields():
                                    field_name = field.name()
                                    # Copy only if the field is not 'fid'
                                    if field_name != 'fid' and field_name in tgt_layer.fields().names():
                                        new_feature[field_name] = feature[field_name]
                                
                                tgt_layer.addFeature(new_feature)
                            tgt_layer.commitChanges()
                            QgsProject.instance().removeMapLayer(clipped_layer.id())
                            print(f"Features from {current_code} successfully copied to {layer_name}.")
                        else:
                            print(f"GeoPackage for {current_code} not found: {gpkg_path}")
                        QgsProject.instance().removeMapLayer(grid_layer.id())
                        iface.messageBar().pushSuccess('PRoW by Canvas:',' Got it!')

                else:
                    iface.messageBar().pushWarning(f"Wrong drive! GeoPackage for grid layer not found: {grid_gpkg_path}")

                # Refresh the canvas to reflect the changes
                iface.mapCanvas().refresh()

                # Print the final list of tile names (codes)
                print("\nFinal list of tile names (codes):")
                print(code)
                
            if prow_layer:
                clipping_layer = self.dlg.prowComboBox.currentLayer()
                grid_gpkg_path = datto + ":/Data/OS OpenData/BNG/OS_bng_grids.gpkg|layername=100km_grid"
                gpkg_base_path = datto + ":/Data/OS OpenData/PRoW_non_definitive"
                layer_name = 'Public Path'

                # Load the grid layer
                grid_layer = QgsVectorLayer(grid_gpkg_path, "Grid Layer", "ogr")
                if not grid_layer.isValid():
                    iface.messageBar().pushWarning("PRoW by Layer",'No grid found on Datto')
                    exit()

                QgsProject.instance().addMapLayer(grid_layer)

                # Find intersecting grid tiles
                intersecting_codes = []
                for grid_feature in grid_layer.getFeatures():
                    grid_geometry = grid_feature.geometry()

                    for clip_feature in clipping_layer.getFeatures():
                        if grid_geometry.intersects(clip_feature.geometry()):
                            tile_name = grid_feature["tile_name"]
                            intersecting_codes.append(tile_name)
                            break  # Stop checking after first intersection

                if not intersecting_codes:
                    iface.pushWarning("PRoW by Layer","No intersecting grids found.")
                    QgsProject.instance().removeMapLayer(grid_layer.id())
                    exit()

                print(f"Intersecting grid codes: {', '.join(intersecting_codes)}")

                # Process each intersecting grid
                for code in intersecting_codes:
                    gpkg_path = f"{gpkg_base_path}/{code}_PRoW.gpkg|layername={code}_PRoW"
                    if not os.path.isfile(gpkg_path.split('|')[0]):
                        print(f"GeoPackage not found for grid {code}: {gpkg_path}")
                        continue

                    # First clip the data
                    result = processing.run("native:clip", {
                        'INPUT': gpkg_path,
                        'OVERLAY': clipping_layer.source(),
                        'OUTPUT': 'TEMPORARY_OUTPUT'
                    })
                    clipped_layer = result['OUTPUT']

                    # Fix geometries after clipping
                    fixed_result = processing.run("native:fixgeometries", {
                        'INPUT': clipped_layer,
                        'OUTPUT': 'TEMPORARY_OUTPUT'
                    })
                    clipped_layer = fixed_result['OUTPUT']
                    clipped_layer.setName(f"temp_{layer_name}_{code}")
                    QgsProject.instance().addMapLayer(clipped_layer)

                    # Copy features to the target layer
                    tgt_layer = QgsProject.instance().mapLayersByName(layer_name)[0]
                    if not tgt_layer:
                        print(f"Target layer '{layer_name}' not found.")
                        QgsProject.instance().removeMapLayer(clipped_layer.id())
                        continue

                    if tgt_layer.readOnly() is True:
                        tgt_layer.setReadOnly(False)
                    fid = tgt_layer.fields().field("fid")
                    fid = 0
                    tgt_layer.startEditing()
                    clipped_layer.selectAll()
                    iface.mapCanvas().refresh()
                    features = [feature for feature in clipped_layer.getFeatures()]
                    for feature in features:
                        fid += 1
                    iface.copySelectionToClipboard(clipped_layer)
                    iface.pasteFromClipboard(tgt_layer)
                    tgt_layer.commitChanges()
                    QgsProject.instance().removeMapLayer(clipped_layer.id())
                    print(f"✅ Processed grid {code} and updated {layer_name}.")
                # Clean up grid layer
                QgsProject.instance().removeMapLayer(grid_layer.id())
                iface.mapCanvas().refresh()

                iface.messageBar().pushSuccess('PRoW by Layer:', ' Got it!')

            
            if map_canvas:
                code = []
                grid_gpkg_path = datto + ":/Data/OS OpenData/BNG/OS_bng_grids.gpkg|layername=100km_grid"
                shp_base_path = datto+":/Data/Mapping/Open Map Local/Shapefiles"
                # Layers to process
                master_layers = [
                    'Woodland',
                    'TidalWater',
                    'TidalBoundary',
                    'SurfaceWater_Line',
                    'SurfaceWater_Area',
                    'Road',
                    'RailwayTrack',
                    'NamedPlace',
                    'Foreshore',
                    'Building'
                ]
                # Get the current canvas extent
                canvas_extent = iface.mapCanvas().extent()

                # Transform CRS if needed
                project_crs = QgsProject.instance().crs()
                canvas_crs = iface.mapCanvas().mapSettings().destinationCrs()
                if project_crs != canvas_crs:
                    canvas_extent = QgsCoordinateTransform(canvas_crs, project_crs, QgsProject.instance()).transform(canvas_extent)

                # Check if the grid layer exists
                if os.path.isfile(grid_gpkg_path.split('|')[0]):
                    # Load the 100km grid layer
                    grid_layer = QgsProject.instance().addMapLayer(QgsVectorLayer(grid_gpkg_path, "Grid Layer", "ogr"))
                    
                    # Find grid features that intersect with the canvas extent
                    request = QgsFeatureRequest().setFilterRect(canvas_extent)
                    intersecting_grids = []

                    for grid_feature in grid_layer.getFeatures(request):
                        # Extract the 'tile_name' from each intersecting grid feature
                        tile_name = grid_feature['tile_name']
                        intersecting_grids.append(tile_name)

                        # Append tile_name to the code list
                        code.append(tile_name)

                    # If intersecting grids found, print the result
                    if intersecting_grids:
                        print(f"Intersecting grid(s) found with tile names: {', '.join(intersecting_grids)}")
                    else:
                        print("No intersecting grids found.")
                    
                    # Now process each master layer for each intersecting grid tile
                    for current_code in code:
                        for layer_name in master_layers:
                            shp_path = f"{shp_base_path}/{current_code}/{current_code}_{layer_name}.shp"
                            
                            if os.path.isfile(shp_path):
                                # Perform clipping for the current shapefile
                                result = processing.run("native:extractbyextent", {
                                    'INPUT': shp_path,
                                    'EXTENT': canvas_extent,
                                    'CLIP': True,
                                    'OUTPUT': 'TEMPORARY_OUTPUT'
                                })

                                clipped_layer = result['OUTPUT']

                                if clipped_layer is None:
                                    print(f"Failed to clip layer: {layer_name} for grid tile {current_code}")
                                    continue

                                clipped_layer.setName(f"temp_{layer_name}_{current_code}")
                                QgsProject.instance().addMapLayer(clipped_layer)

                                # Get the target layer where features should be copied
                                target_layer = QgsProject.instance().mapLayersByName(layer_name)
                                if not target_layer:
                                    print(f"Target layer not found: {layer_name}")
                                    QgsProject.instance().removeMapLayer(clipped_layer.id())
                                    continue
                                tgt_layer = target_layer[0]
                                if tgt_layer.readOnly() is True:
                                    tgt_layer.setReadOnly(False)
                                
                                # Copy features from the clipped layer to the target layer
                                tgt_layer.startEditing()
                                for feature in clipped_layer.getFeatures():
                                    new_feature = QgsFeature(tgt_layer.fields())
                                    new_feature.setGeometry(feature.geometry())

                                    for field in feature.fields():
                                        if field in tgt_layer.fields().names():
                                            new_feature[field] = feature[field]
                                    tgt_layer.addFeature(new_feature)
                                tgt_layer.commitChanges()
                                QgsProject.instance().removeMapLayer(clipped_layer.id())
                                print(f"Features from {layer_name} ({current_code}) successfully copied to target layer.")
                            else:
                                print(f"Shapefile not found: {shp_path}")

                else:
                    print(f"GeoPackage for grid layer not found: {grid_gpkg_path}")

                # Refresh the canvas to reflect changes
                iface.mapCanvas().refresh()

                # Print final list of tile names (codes)
                print("\nFinal list of tile names (codes):")
                print(code)
                QgsProject.instance().removeMapLayer(grid_layer.id())
                iface.messageBar().pushSuccess('Map by Canvas:',' Got it!')
        
            if map_layer:
                clipping_layer =self.dlg.mapComboBox.currentLayer()
                code = []
                grid_gpkg_path = datto + ":/Data/OS OpenData/BNG/OS_bng_grids.gpkg|layername=100km_grid"
                shp_base_path = datto + ":/Data/Mapping/Open Map Local/Shapefiles"
                master_layers = [
                'Woodland', 'TidalWater', 'TidalBoundary', 'SurfaceWater_Line', 'SurfaceWater_Area',
                'Road', 'RailwayTrack', 'NamedPlace', 'Foreshore', 'Building'
                 ]
                
                '''
                clipping_features = [feature for feature in clipping_layer.getFeatures()]
                temp_layer = QgsVectorLayer("Polygon?crs=" + clipping_layer.crs().authid(), "temp_extent", "memory")
                temp_layer.startEditing()
                temp_layer_data = temp_layer.dataProvider()
                temp_layer.commitChanges()
               

                # Add features to temporary layer
                for feature in clipping_features:
                    temp_layer_data.addFeatures([feature])
                    '''

                grid_layer = QgsVectorLayer(grid_gpkg_path, "Grid Layer", "ogr")
                if not grid_layer.isValid():
                    print("Failed to load the grid layer.")
                    exit()
                    
                QgsProject.instance().addMapLayer(grid_layer)

                # Find intersecting grid tiles
                intersecting_codes = []
                for grid_feature in grid_layer.getFeatures():
                    grid_geometry = grid_feature.geometry()

                    for clip_feature in clipping_layer.getFeatures():
                        if grid_geometry.intersects(clip_feature.geometry()):
                            tile_name = grid_feature["tile_name"]
                            intersecting_codes.append(tile_name)
                            break  # Stop checking after first intersection

                    # If intersecting grids found, print the result
                if not intersecting_codes:
                    iface.messageBar().pushWarning("BackMapping by Layer","No intersecting grids found.")
                    QgsProject.instance().removeMapLayer(grid_layer.id())
                    exit()
                print(f"Intersecting grid codes: {', '.join(intersecting_codes)}")

                    # Process each master layer for each intersecting grid tile
                for current_code in intersecting_codes:
                    for layer_name in master_layers:
                        shp_path = f"{datto}:/Data/Mapping/Open Map Local/Shapefiles/{current_code}/{current_code}_{layer_name}.shp"
                        print(f"Checking shapefile: {shp_path}")

                        if os.path.isfile(shp_path):
                            # Perform clipping for the current shapefile
                            result = processing.run("native:clip", {
                                'INPUT': shp_path,
                                'OVERLAY': clipping_layer,
                                'OUTPUT': 'TEMPORARY_OUTPUT'
                            })

                            clipped_layer = result['OUTPUT']

                            
                            clipped_layer.setName(f"temp_{layer_name}")
                            QgsProject.instance().addMapLayer(clipped_layer)

                            # Copy features from the clipped layer to the target layer
                            target_layer = QgsProject.instance().mapLayersByName(layer_name)
                            if target_layer:
                                tgt_layer = target_layer[0]
                                if tgt_layer.readOnly() is True:
                                    tgt_layer.setReadOnly(False)

                                tgt_layer.startEditing()

                                for feature in clipped_layer.getFeatures():
                                    new_feature = QgsFeature(tgt_layer.fields())
                                    new_feature.setGeometry(feature.geometry())
                                    for field in feature.fields():
                                        if field in tgt_layer.fields().names():
                                            new_feature[field] = feature[field]
                                    tgt_layer.addFeature(new_feature)

                                tgt_layer.commitChanges()
                            
                                print(f"Features from {layer_name} ({current_code}) successfully copied.")
                            else:
                                iface.messgaeBar().pushWarning("Master map layer error", f"{layer_name} not existing")
                            QgsProject.instance().removeMapLayer(clipped_layer.id())
                            

                    QgsProject.instance().removeMapLayer(grid_layer.id())
               

                # Refresh the canvas to reflect changes
                iface.mapCanvas().refresh()
                iface.messageBar().pushSuccess('Map by Layer:',' Got it!')


            if constraint_checker:
                proposed_layer = self.dlg.proposedLayer.currentLayer()
                if proposed_layer is None:
                    iface.messageBar().pushWarning("Constraint Checker", "No layer selected in Proposed Layer field.")
                    return
                for layer in iface.layerTreeView().selectedLayers():
                    processing.run("native:selectbylocation", {
                        'INPUT':proposed_layer,
                        'PREDICATE':[0],
                        'INTERSECT': layer.source(),
                        'METHOD':1})
                    
                selected_feature_count = proposed_layer.selectedFeatureCount()

                if selected_feature_count == 0:
                    iface.messageBar().pushSuccess('Constraint Checker:', "Weheyeeeee! None of your proposed archaeology intersect your selected constraints")
                    
                else:
                    QMessageBox.warning(None, "Constraint Checker", 
                                        f'{selected_feature_count} features are intersecting with your constraints :(')

            if check_directory:
                home_dir = QgsProject.instance().homePath()
                layers = QgsProject.instance().mapLayers().values()
                layer_count = 0
                for layer in layers:
                    if layer.providerType() in ["xyz", "wms", "wmts"]:
                        continue
                    if not layer.source().startswith(home_dir):
                        layer_count += 1
                        iface.messageBar().pushWarning('Directory Checker:',f"Layer '{layer.name()}' is not in the project home directory.")
                if layer_count > 0:
                    QMessageBox.warning(None, "Directory Checker", 
                    f'{str(layer_count)} layers are not in your project home directory\n')
                else:
                     iface.messageBar().pushSuccess('Directory Checker:',' All good!')
            if check_utilityLine:
                ug_layer = QgsProject.instance().mapLayersByName('Services UG')[0] if QgsProject.instance().mapLayersByName('Services UG') else None
                oh_layer = QgsProject.instance().mapLayersByName('Services OH')[0] if QgsProject.instance().mapLayersByName('Services OH') else None
                ug_buffer_layer = QgsProject.instance().mapLayersByName('Buffer Underground')[0] if QgsProject.instance().mapLayersByName('Buffer Underground') else None
                oh_buffer_layer = QgsProject.instance().mapLayersByName('Buffer Overhead')[0] if QgsProject.instance().mapLayersByName('Buffer Overhead') else None
                
                self.check_utility_line(oh_layer, oh_buffer_layer, 'OH')
                self.check_utility_line(ug_layer, ug_buffer_layer, 'UG')             

            if tr_machineSpace:
                proposed_layer = self.dlg.proposedLayer.currentLayer()
                if proposed_layer is None:
                    iface.messageBar().pushWarning("Machine Travel Space (TR)", "No layer selected in Proposed Layer field.")
                    return
                result = processing.run("native:buffer", {
                    'INPUT': proposed_layer,
                    'DISTANCE': 2.5,
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                })

                buffer_layer = result['OUTPUT']
                buffered_features = list(buffer_layer.getFeatures())
                
                # Step 2: Find overlapping buffered features
                overlapping_feature_ids = set()
                for i, feature1 in enumerate(buffered_features):
                    geom1 = feature1.geometry()
                    for j, feature2 in enumerate(buffered_features):
                        if i != j and geom1.overlaps(feature2.geometry()):  # Partial overlaps only
                            overlapping_feature_ids.add(feature1["fid"])
                            overlapping_feature_ids.add(feature2["fid"])
                
                # Step 3: Select original features in proposed_layer based on overlapping buffer features
                if overlapping_feature_ids:
                    print(f"⚠️ Selecting {len(overlapping_feature_ids)} overlapping features in Proposed Layer...")
                    QMessageBox.warning(None, "Machine Travel Space for Trenching", 
                                        f'{len(overlapping_feature_ids)} trenches are having a space less than 5m for machine to travel around it.\nPlease check selected features in the attribute table')
                    proposed_layer.selectByIds(list(overlapping_feature_ids))
                else:
                    iface.messageBar().pushSuccess('Machine Travel Space for Trenching:', ' We got enough space!')
                    print("✅ No overlapping features found.")
               
                iface.mapCanvas().refresh()

            if tr_stakeout and other_stakeout:
                self.other_stakeout_func()
                self.trench_stakeout_func()
                tr_stakeout_name = 'Trench_Stakeout_Point'
                other_stakeout_name = 'merged_vertex_for_stakeout'
                tr_stakeout_layer = QgsProject.instance().mapLayersByName(tr_stakeout_name)[0] if QgsProject.instance().mapLayersByName(tr_stakeout_name) else None
                other_stakeout_layer = QgsProject.instance().mapLayersByName(other_stakeout_name)[0] if QgsProject.instance().mapLayersByName(other_stakeout_name) else None
                result_merge = processing.run("native:mergevectorlayers", {
                    'LAYERS':[tr_stakeout_layer, other_stakeout_layer],
                    'CRS':QgsCoordinateReferenceSystem('EPSG:27700'),
                    'OUTPUT':'TEMPORARY_OUTPUT'
                })

                result_merge = result_merge['OUTPUT']
                result_merge.setName('merged_stakeout')
                QgsProject.instance().addMapLayer(result_merge)
                QgsProject.instance().removeMapLayer(tr_stakeout_layer)
                QgsProject.instance().removeMapLayer(other_stakeout_layer)
            elif tr_stakeout and not other_stakeout:
                self.trench_stakeout_func()

            elif other_stakeout and not tr_stakeout:
                self.other_stakeout_func()